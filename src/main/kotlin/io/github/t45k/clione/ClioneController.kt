package io.github.t45k.clione

import com.auth0.jwt.JWT
import com.auth0.jwt.algorithms.Algorithm
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.ObjectMapper
import org.bouncycastle.jce.provider.BouncyCastleProvider
import org.kohsuke.github.GHAppInstallationToken
import org.kohsuke.github.GitHub
import org.kohsuke.github.GitHubBuilder
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RestController
import util.DigestUtil
import java.security.Security
import java.security.interfaces.RSAPrivateKey
import java.util.Calendar
import java.util.Date
import java.util.ResourceBundle
import javax.servlet.http.HttpServletRequest

@RestController
class ClioneApiController {
    private val logger: Logger = LoggerFactory.getLogger(this::class.java)
    private val githubPrivateKey: RSAPrivateKey
    private val githubAppIdentifier: String
    private val githubWebhookSecret: String

    init {
        Security.addProvider(BouncyCastleProvider())

        val bundle: ResourceBundle = ResourceBundle.getBundle("resource") ?: throw NoPropertyFileExistsException()
        githubPrivateKey = DigestUtil.getRSAPrivateKeyFromPEMFileContents(bundle.getString("GITHUB_PRIVATE_KEY"))
        githubAppIdentifier = bundle.getString("GITHUB_APP_IDENTIFIER")
        githubWebhookSecret = bundle.getString("GITHUB_WEBHOOK_SECRET")
    }

    companion object {
        const val WEBHOOK_SIGNATURE: String = "x-hub-signature"
        const val WEBHOOK_EVENT: String = "x-github-event"
    }

    @Autowired
    private lateinit var request: HttpServletRequest

    @GetMapping("")
    fun home(): String = "hello"

    @PostMapping("/event_handler")
    fun postEventHandler(@RequestBody rawRequestBody: String) {
        logger.info("Event was received")
        if (!verifyWebhookSignature(rawRequestBody)) {
            return
        }

        val event: String = request.getHeader(WEBHOOK_EVENT)
        val json: JsonNode = ObjectMapper().readTree(rawRequestBody)
        val action: String = json["action"].asText()
        logger.info("---- received event $event:String from ${json["repository"]["full_name"].asText()}")
        logger.info("---- action $action")
        if (!isPullRequestOpen(event, action)) {
            return
        }

        val client: GitHub = authenticateApp()
            .run { authenticateInstallation(json, this) }
        client
            .getRepository(json["repository"]["full_name"].asText())
            .getIssue(json["number"].asInt())
            .comment("hello")
    }

    private fun isPullRequestOpen(event: String, action: String): Boolean =
        event == "pull_request" && action == "opened"

    /**
     * Check X-Hub-Signature to confirm that this webhook was generated by
     * GitHub, and not a malicious third party.
     *
     * GitHub uses the WEBHOOK_SECRET, registered to the GitHub App, to
     * create the hash signature sent in the `X-HUB-Signature` header of each
     * webhook. This code computes the expected hash signature and compares it to
     * the signature sent in the `X-HUB-Signature` header. If they don't match,
     * this request is an attack, and you should reject it. GitHub uses the HMAC
     * hexdigest to compute the signature. The `X-HUB-Signature` looks something
     * like this: "sha1=123456".
     * See https://developer.github.com/webhooks/securing/ for details.
     *
     * @param rawBody raw request body
     *
     * @return verification is OK or NO
     */
    private fun verifyWebhookSignature(rawBody: String): Boolean {
        val requestHeader: String = request.getHeader(WEBHOOK_SIGNATURE)
        val (algorithm: String, requestDigest: String) = requestHeader.split("=")
        val myDigest: String = DigestUtil.digest("hmac$algorithm", githubWebhookSecret, rawBody)
        return if (requestDigest == myDigest) {
            true
        } else {
            logger.error("Unauthorized Access")
            false
        }
    }

    /**
     * Instantiate a GitHub client authenticated as a GitHub App.
     * GitHub App authentication requires that you construct a
     * JWT (https://jwt.io/introduction/) signed with the app's private key,
     * so GitHub can be sure that it came from the app and was not altered by
     * a malicious third party.
     */
    private fun authenticateApp(): GitHub {
        val nowTime = Date()
        val expiredTime: Date = nowTime.minutesAfter(10)

        val jwt: String = JWT.create()
            .withIssuedAt(nowTime)
            .withExpiresAt(expiredTime)
            .withIssuer(githubAppIdentifier)
            .sign(Algorithm.RSA256(null, githubPrivateKey))

        return GitHubBuilder().withJwtToken(jwt).build()
    }

    /**
     * Instantiate a GitHub client, authenticated as an installation of a
     * GitHub App, to run API operations.
     */
    @Suppress("DEPRECATION")
    private fun authenticateInstallation(json: JsonNode, appClient: GitHub): GitHub {
        val installationId: Long = json["installation"]["id"].asLong()
        val installation: GHAppInstallationToken = appClient.app.getInstallationById(installationId)
            .createToken()
            .create()
        return GitHubBuilder().withAppInstallationToken(installation.token).build()
    }

    private fun Date.minutesAfter(minutes: Int): Date =
        Calendar.getInstance()
            .also {
                it.time = this
                it.add(Calendar.MINUTE, minutes)
            }
            .time
}

class NoPropertyFileExistsException : RuntimeException()
