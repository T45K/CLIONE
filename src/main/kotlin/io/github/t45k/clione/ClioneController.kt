package io.github.t45k.clione

import com.auth0.jwt.JWT
import com.auth0.jwt.algorithms.Algorithm
import com.fasterxml.jackson.core.type.TypeReference
import com.fasterxml.jackson.databind.ObjectMapper
import org.apache.commons.codec.binary.Hex
import org.bouncycastle.jce.provider.BouncyCastleProvider
import org.bouncycastle.util.io.pem.PemReader
import org.kohsuke.github.GHAppInstallationToken
import org.kohsuke.github.GitHub
import org.kohsuke.github.GitHubBuilder
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RestController
import java.io.StringReader
import java.security.KeyFactory
import java.security.Security
import java.security.interfaces.RSAPrivateKey
import java.security.spec.PKCS8EncodedKeySpec
import java.util.Calendar
import java.util.Date
import java.util.ResourceBundle
import javax.crypto.Mac
import javax.crypto.spec.SecretKeySpec
import javax.servlet.http.HttpServletRequest


@RestController
class ClioneApiController {
    private val logger: Logger = LoggerFactory.getLogger(this::class.java)
    private val githubPrivateKey: RSAPrivateKey
    private val githubAppIdentifier: String
    private val githubWebhookSecret: String

    init {
        val bundle = ResourceBundle.getBundle("resource") ?: throw NoPropertyFileExistsException()
        Security.addProvider(BouncyCastleProvider())

        githubPrivateKey = PemReader(StringReader(bundle.getString("GITHUB_PRIVATE_KEY")))
            .readPemObject()
            .let { PKCS8EncodedKeySpec(it.content) }
            .let { KeyFactory.getInstance("RSA").generatePrivate(it) as RSAPrivateKey }
        githubAppIdentifier = bundle.getString("GITHUB_APP_IDENTIFIER")
        githubWebhookSecret = bundle.getString("GITHUB_WEBHOOK_SECRET")
    }

    @Autowired
    private lateinit var request: HttpServletRequest

    @GetMapping("")
    fun home() {
    }

    @PostMapping("/event_handler")
    fun postEventHandler(@RequestBody rawBody: String) {
        logger.info("Event was received")
        val parsedBody: Map<String, Any?> = ObjectMapper().readValue(rawBody, object : TypeReference<Map<String, Any?>>() {})
        if (!verifyWebhookSignature(rawBody, parsedBody)) {
            return
        }

        val gitHub = authenticateApp()
        val tmp = authenticateInstallation(parsedBody, gitHub)
        tmp.getRepository((parsedBody["repository"] as Map<*, *>)["full_name"] as String).getIssue((parsedBody["issue"] as Map<*, *>)["number"] as Int).comment("hogehoge")
    }

    /**
     * Check X-Hub-Signature to confirm that this webhook was generated by
     * GitHub, and not a malicious third party.
     *
     * GitHub uses the WEBHOOK_SECRET, registered to the GitHub App, to
     * create the hash signature sent in the `X-HUB-Signature` header of each
     * webhook. This code computes the expected hash signature and compares it to
     * the signature sent in the `X-HUB-Signature` header. If they don't match,
     * this request is an attack, and you should reject it. GitHub uses the HMAC
     * hexdigest to compute the signature. The `X-HUB-Signature` looks something
     * like this: "sha1=123456".
     * See https://developer.github.com/webhooks/securing/ for details.
     *
     * @param rawBody raw request body
     * @param parsedBody request body parsed as key-value object(json)
     *
     * @return verification is OK or NO
     */
    private fun verifyWebhookSignature(rawBody: String, parsedBody: Map<String, Any?>): Boolean {
        val requestHeader: String = request.getHeader("x-hub-signature")
        val (method: String, requestDigest: String) = requestHeader.split("=")
        val myDigest: String = digest("hmac$method", rawBody)
        if (requestDigest != myDigest) {
            logger.error("Unauthorized Access")
            return false
        }

        if (parsedBody["action"] == null) {
            logger.warn("No action occurred")
            return false
        }

        logger.info("---- received event ${request.getHeader("x-github-event")}")
        logger.info("---- action ${parsedBody["action"]}")
        return true
    }

    /**
     * Perform HMAC SHA1 HEX Digest
     *
     * @param method hashing algorithm. Ordinarily, only SHA1 is given.
     */
    private fun digest(method: String, rawBody: String): String =
        Mac.getInstance(method)
            .also {
                val secretKeySpec = SecretKeySpec(githubWebhookSecret.toByteArray(), method)
                it.init(secretKeySpec)
            }
            .doFinal(rawBody.toByteArray())
            .let(Hex::encodeHex)
            .let { String(it) }

    private fun authenticateApp(): GitHub {
        val now = Date()
        val expired: Date = Calendar.getInstance()
            .apply { this.time = now }
            .apply { this.add(Calendar.MINUTE, 10) }
            .time

        val jwt: String = JWT.create()
            .withIssuedAt(now)
            .withExpiresAt(expired)
            .withIssuer(githubAppIdentifier)
            .sign(Algorithm.RSA256(githubPrivateKey))
        return GitHubBuilder().withJwtToken(jwt).build()
    }

    private fun authenticateInstallation(parsedBody: Map<String, Any?>, appClient: GitHub): GitHub {
        val installationId: Long = ((parsedBody["installation"] as Map<*, *>)["id"] as Int).toLong()
        val installation: GHAppInstallationToken = appClient.app.getInstallationById(installationId)
            .createToken()
            .create()
        return GitHubBuilder().withAppInstallationToken(installation.token).build()
    }
}

class NoPropertyFileExistsException : RuntimeException()
